<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="eu.europa.ec.cc.processcentre.process.query.repository.QueryMapper">

  <resultMap id="ProcessResult" type="eu.europa.ec.cc.processcentre.process.query.repository.model.SearchProcessQueryResponse">
    <id property="processInstanceId" column="process_instance_id"/>
    <result property="title" column="process_title"/>
    <result property="activeTasks" column="tasks"/>
    <result property="totalCount" column="total_count"/>
    <result property="status" column="status"/>
    <result property="cardLayout" column="result_card"/>
  </resultMap>

  <sql id="processesCte">
    WITH RECURSIVE
    <if test="(sortProperty != null and sortProperty.startsWith('specificAttributes.'))
      or (specificAttributes != null and specificAttributes.size() > 0)">
      <!-- we need to store or filter on a given variable, we need to add an additional cte -->
    filter_variables AS (
      select process_instance_id from t_process_variable
      <where>

      </where>
    ),
    </if>
    matching_roots AS (
    SELECT p.process_instance_id, p.status, p.result_card, p.created_on,
    COUNT(*) OVER() AS total_count
    FROM t_process p
    <include refid="whereClause"/>
    <choose>
      <when test="sortProperty != null and sortProperty.startsWith('specificAttributes.')">
        ORDER BY (
        SELECT pv.value::int
        FROM T_PROCESS_VARIABLES pv
        WHERE pv.process_id = p.id AND pv.name = #{sortProperty}
        LIMIT 1
        )
      </when>
      <otherwise>
        ORDER BY p.created_on desc
      </otherwise>
    </choose>
    LIMIT #{limit} OFFSET #{offset}),
    descendants AS (SELECT p.process_instance_id, p.parent_process_instance_id
    FROM t_process p
    JOIN matching_roots r ON p.process_instance_id = r.process_instance_id
    UNION ALL
    SELECT tp.process_instance_id, tp.parent_process_instance_id
    FROM t_process tp
    JOIN descendants d ON tp.parent_process_instance_id = d.process_instance_id),
    relevant_tasks AS (
    SELECT t.task_instance_id, t.process_instance_id
    FROM t_user_task t
    JOIN descendants d ON t.process_instance_id = d.process_instance_id
    WHERE t.status IN ('CREATED', 'ASSIGNED')
    ),
    task_titles AS (
    SELECT t.task_instance_id, t.process_instance_id, tt.translated_text AS task_title
    FROM relevant_tasks t
    LEFT JOIN t_static_translation tt
    ON tt.object_id = t.task_instance_id
    AND tt.language_code = #{locale}
    AND tt.object_type = 'TASK'
    AND tt.attribute_name = 'TASK_TITLE'
    ),
    aggregated_tasks AS (
    SELECT
    t.process_instance_id,
    json_agg(json_build_object(
    'task_instance_id', t.task_instance_id,
    'task_title', t.task_title
    )) AS tasks
    FROM task_titles t
    GROUP BY t.process_instance_id
    ),
    processes AS (
    SELECT
    r.process_instance_id,
    r.total_count,
    pt.translated_text AS process_title,
    COALESCE(at.tasks, '[]'::json) AS tasks
    FROM matching_roots r
    LEFT JOIN (
    SELECT object_id, translated_text
    FROM t_static_translation
    WHERE language_code = #{locale}
    AND object_type = 'PROCESS'
    AND attribute_name = 'PROCESS_TITLE'
    ) pt ON pt.object_id = r.process_instance_id
    LEFT JOIN aggregated_tasks at ON at.process_instance_id = r.process_instance_id
    )
  </sql>

  <sql id="whereClause">
    <where>
      <if test="securityFilters != null and securityFilters.size() > 0">
        <foreach item="filter" collection="securityFilters" separator="OR" open="(" close=")">
          (
            p.SECURITY_SECUNDA_TASK = #{filter.secundaTask}
            <foreach collection="filter.secundaScopes" item="scope" separator="AND">
              <if test="scope.scopeIds != null and !scope.scopeIds.isEmpty()">
                AND p.SECURITY_SCOPE_TYPE_ID = #{scope.scopeTypeId}
                <choose>
                  <when test="scope.scopeTypeId == 'EC-Hierarchy'">
                    <!-- For EC-Hierarchy we need to do a start with query -->
                    AND
                    <foreach collection="scope.scopeIds" item="scopeId" separator="AND">
                      p.SECURITY_SCOPE_ID ILIKE CONCAT (#{scopeId}, '%')
                    </foreach>
                  </when>
                  <otherwise>
                    <!-- For other scope types we do an exact match -->
                    AND p.SECURITY_SCOPE_ID IN
                    <foreach collection="scope.scopeIds" item="scopeId" open="(" separator="," close=")">
                      #{scopeId}
                    </foreach>
                  </otherwise>
                </choose>
              </if>
            </foreach>
          )
        </foreach>
      </if>
      <if test="searchText != null and searchText != ''">
        AND p.SEARCH_VECTOR @@ to_tsquery('simple', #{searchText})
      </if>
      <if test="statuses != null and statuses.size() > 0">
        AND p.STATUS IN
        <foreach item="status" collection="statuses" separator="," open="(" close=")">
          #{runningStatus}
        </foreach>
      </if>
    </where>
  </sql>

  <select id="search" resultMap="ProcessResult" resultType="eu.europa.ec.cc.processcentre.process.query.repository.model.SearchProcessQueryResponse">
    <include refid="processesCte"/>
    SELECT r.process_instance_id as process_instance_id,
    r.total_count as total_count,
    pt.translated_text    AS process_title,
    COALESCE(at.tasks, '[]'::json) AS tasks,
    r.status as status,
    r.result_card as result_card
    FROM matching_roots r
    LEFT JOIN (SELECT object_id, translated_text
    FROM t_static_translation
    WHERE language_code = #{locale}
    AND object_type = 'PROCESS'
    AND attribute_name = 'PROCESS_TITLE'
    AND object_id IN (SELECT process_instance_id FROM matching_roots)) pt
    ON pt.object_id = r.process_instance_id
    LEFT JOIN aggregated_tasks at ON at.process_instance_id = r.process_instance_id
  </select>

  <!--  <select id="countStations" resultType="eu.europa.ec.cc.processcentre.repository.model.MetroLineStationStats">-->
  <!--    WITH RECURSIVE process_tree AS (-->
  <!--    SELECT-->
  <!--    p.PROCESS_INSTANCE_ID,-->
  <!--    p.PROCESS_TYPE_ID,-->
  <!--    p.COMPLETED,-->
  <!--    p.PARENT_ID-->
  <!--    FROM-->
  <!--    T_PROCESS p-->
  <!--    UNION ALL-->
  <!--    SELECT-->
  <!--    child.PROCESS_INSTANCE_ID,-->
  <!--    child.PROCESS_TYPE_ID,-->
  <!--    child.COMPLETED,-->
  <!--    child.PARENT_ID-->
  <!--    FROM-->
  <!--    T_PROCESS child-->
  <!--    JOIN process_tree parent-->
  <!--    ON child.PARENT_ID = parent.PROCESS_INSTANCE_ID-->
  <!--    ),-->
  <!--    ongoing_processes AS (-->
  <!--    SELECT-->
  <!--    m.STATION_NAME,-->
  <!--    COUNT(DISTINCT p.PROCESS_INSTANCE_ID) AS count_ongoing_processes-->
  <!--    FROM-->
  <!--    process_tree p-->
  <!--    JOIN-->
  <!--    T_METRO_LINE_MAPPING m-->
  <!--    ON p.PROCESS_TYPE_ID = m.PROCESS_TYPE_ID-->
  <!--    WHERE-->
  <!--    p.COMPLETED = FALSE-->
  <!--    GROUP BY-->
  <!--    m.STATION_NAME-->
  <!--    ),-->
  <!--    completed_processes AS (-->
  <!--    SELECT-->
  <!--    m.STATION_NAME,-->
  <!--    COUNT(DISTINCT p.PROCESS_INSTANCE_ID) AS count_completed_processes-->
  <!--    FROM-->
  <!--    process_tree p-->
  <!--    JOIN-->
  <!--    T_METRO_LINE_MAPPING m-->
  <!--    ON p.PROCESS_TYPE_ID = m.PROCESS_TYPE_ID-->
  <!--    WHERE-->
  <!--    p.COMPLETED = TRUE-->
  <!--    GROUP BY-->
  <!--    m.STATION_NAME-->
  <!--    ),-->
  <!--    ongoing_tasks AS (-->
  <!--    SELECT-->
  <!--    m.STATION_NAME,-->
  <!--    COUNT(DISTINCT t.TASK_INSTANCE_ID) AS count_ongoing_tasks-->
  <!--    FROM-->
  <!--    process_tree p-->
  <!--    JOIN-->
  <!--    T_USER_TASK t-->
  <!--    ON p.PROCESS_INSTANCE_ID = t.PROCESS_INSTANCE_ID-->
  <!--    JOIN-->
  <!--    T_METRO_LINE_MAPPING m-->
  <!--    ON t.TASK_TYPE_ID = m.TASK_TYPE_ID-->
  <!--    WHERE-->
  <!--    t.COMPLETED = FALSE-->
  <!--    GROUP BY-->
  <!--    m.STATION_NAME-->
  <!--    ),-->
  <!--    processes_in_business_state AS (-->
  <!--    SELECT-->
  <!--    m.STATION_NAME,-->
  <!--    COUNT(DISTINCT pbs.PROCESS_INSTANCE_ID) AS count_processes_in_business_state-->
  <!--    FROM-->
  <!--    process_tree p-->
  <!--    JOIN-->
  <!--    T_PROCESS_BUSINESS_STATE pbs-->
  <!--    ON p.PROCESS_INSTANCE_ID = pbs.PROCESS_INSTANCE_ID-->
  <!--    JOIN-->
  <!--    T_METRO_LINE_MAPPING m-->
  <!--    ON pbs.BUSINESS_STATE = m.BUSINESS_STATE-->
  <!--    GROUP BY-->
  <!--    m.STATION_NAME-->
  <!--    )-->
  <!--    SELECT-->
  <!--    m.STATION_NAME AS stationName,-->
  <!--    COALESCE(op.count_ongoing_processes, 0) AS ongoingProcesses,-->
  <!--    COALESCE(cp.count_completed_processes, 0) AS completedProcesses,-->
  <!--    COALESCE(ot.count_ongoing_tasks, 0) AS ongoingTasks,-->
  <!--    COALESCE(pbs.count_processes_in_business_state, 0) AS processesInBusinessState-->
  <!--    FROM-->
  <!--    (SELECT DISTINCT STATION_NAME FROM T_METRO_LINE_MAPPING) m-->
  <!--    LEFT JOIN-->
  <!--    ongoing_processes op ON m.STATION_NAME = op.STATION_NAME-->
  <!--    LEFT JOIN-->
  <!--    completed_processes cp ON m.STATION_NAME = cp.STATION_NAME-->
  <!--    LEFT JOIN-->
  <!--    ongoing_tasks ot ON m.STATION_NAME = ot.STATION_NAME-->
  <!--    LEFT JOIN-->
  <!--    processes_in_business_state pbs ON m.STATION_NAME = pbs.STATION_NAME-->
  <!--    ORDER BY-->
  <!--    m.STATION_NAME-->
  <!--  </select>-->

</mapper>